#' Creates the count matrix using either a fragment file or one bam file per cell
#' 
#' @param reads BamFileList, Grange object or dgCMatrix object dependent 
#'              on the original input file type (see main wrapper function)
#' @param windows binned genome as generated by the makeWindows function
#' @param by barcode information
#' @param minFrags Minimum number of fragments a barcode must contain to be counted as a cell
#' @param mapqFilter Filter bam files after a certain mapq value
#' @export
countInsertions <- function(reads, windows, by=NULL, minFrags=NULL, mapqFilter=NULL) {
  UseMethod("countInsertions")
}

countInsertions.BamFileList <- function(reads, windows, by=NULL, minFrags=NULL, mapqFilter=10){
  # seqlevelsStyle(windows) <- 'NCBI'
  message("Counting reads from bam files .. ")
  counts_bam <- GenomicAlignments::summarizeOverlaps(windows, reads, singleEnd=TRUE, 
                                                     fragments=FALSE, mode='Union',
                                                     param = Rsamtools::ScanBamParam(mapqFilter=mapqFilter), 
                                                     ignore.strand = TRUE)
  sparseM <- Matrix(assays(counts_bam)$counts, sparse = TRUE)
  # frip <- 1
  # total <- colSums(sparseM)
  # out <- list(counts = sparseM, frip = frip, total = total)
  return(sparseM)
}

countInsertions.GRanges <- function(reads, windows, by = "barcode", minFrags = 20000, mapqFilter=NULL){
  message("Counting reads from fragments/bed file .. ")
  tabRG <- table(mcols(reads)[[by]])
  keep <- names(tabRG)[which(tabRG >= minFrags)]
  reads <- reads[mcols(reads)[[by]] %in% keep,]
  reads <- sort(sortSeqlevels(reads))
  
  if(length(intersect(seqlevels(windows),seqlevels(reads)))==0){
     stop(paste0("Chromosome names not matching! Potentially use another genome (UCSC or NCBI).
                  \nGenome chromosomes:",paste(head(seqlevels(windows)),collapse=" "),
                  "\nFragment chromosomes:",paste(head(seqlevels(reads)),collapse=" ")))}
  
  overlapDF <- DataFrame(findOverlaps(windows, reads, ignore.strand = TRUE, 
                                      maxgap=-1L, minoverlap=0L, type = "any"))
  overlapDF$name <- mcols(reads)[overlapDF[, 2], by]
  overlapTDF <- transform(overlapDF, id = match(name, unique(name)))
  sparseM <- Matrix::sparseMatrix(
    i = overlapTDF[, 1],
    j = overlapTDF[, 4],
    x = rep(1, nrow(overlapTDF)),
    dims = c(length(windows), length(unique(overlapDF$name))))
  colnames(sparseM) <- unique(overlapDF$name)
  return(sparseM)
}

# Version of the function based on an already created count matrix 
# that needs to be reformated to the correct windows
countInsertions.dgCMatrix<-function(reads, windows, by=NULL, minFrags=NULL, mapqFilter=NULL){
  
  #Create a Grange from peak matrix
  peak_region<-as.data.frame(t(sapply(strsplit(rownames(reads),split="-"),"[")))
  peak_grange<-makeGRangesFromDataFrame(peak_region,
                                        seqnames.field="V1",
                                        start.field="V2",
                                        end.field="V3")
  
  #Find overlaps between peaks and windows
  overlapDF <- as.data.frame(findOverlaps(windows, peak_grange, ignore.strand = TRUE, 
                                          maxgap=-1L, minoverlap=0L, type = "any"))
  
  
  #Reformat peak matrix to window matrix
  count_mat<-reads[overlapDF$subjectHits,]
  
  #Calculate some of peaks overlapping the same window
  overlapDF$queryHits<-factor(overlapDF$queryHits,
                              levels=c(1:length(windows)))
  count_mat <- apply(count_mat, 2, tapply, overlapDF$queryHits, sum, na.rm=T)
  
  #Set NA values to 0 (=windows with no overlapping peaks)
  count_mat[is.na(count_mat)]<-0
  
  #Reformat again to a dgCMatrix object
  count_mat<-as(count_mat,"dgCMatrix")
  
  #Remove rownames (otherwise problem with downstream processing)
  rownames(count_mat)<-NULL
  
  return(count_mat)
}